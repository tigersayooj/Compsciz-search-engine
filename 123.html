<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1"><META NAME="Generator" CONTENT="Microsoft Word 98"><TITLE>Declaring Variables in Assembly Language</TITLE></HEAD><BODY><B><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">Declaring Variables in Assembly Language</P></B><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">As in Java, variables must be declared before they can be used. Unlike Java, we do not specify a variable <B>type</B> in the declaration in assembly language. Instead we declare the name and <B>size</B> of the variable, i.e. the number of bytes the variable will occupy. We may also specify an initial value. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">A <B>directive</B> (i.e. a command to the assembler) is used to define variables. In 8086 assembly language, the directive </FONT><B><FONT FACE="Courier" SIZE=5>db</B></FONT><FONT FACE="Times" SIZE=5> defines a byte sized variable;</FONT><FONT FACE="Courier" SIZE=5> <B>dw</B></FONT><FONT FACE="Times" SIZE=5> defines a word sized variable (16 bits) and</FONT><FONT FACE="Courier" SIZE=5> <B>dd</B></FONT><FONT FACE="Times" SIZE=5> defines a double word (long word, 32 bits) variable. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">A Java variable of type </FONT><B><FONT FACE="Courier" SIZE=5>int</B></FONT><FONT FACE="Times" SIZE=5> may be implemented using a size of 16 or 32 bits, i.e. </FONT><B><FONT FACE="Courier" SIZE=5>dw</B></FONT><FONT FACE="Times" SIZE=5> or </FONT><B><FONT FACE="Courier" SIZE=5>dd</B></FONT><FONT FACE="Times" SIZE=5> is used. A Java variable of type </FONT><FONT FACE="Courier" SIZE=5>char</FONT><FONT FACE="Times" SIZE=5>, which is used to store a single character, is implemented using the </FONT><B><FONT FACE="Courier" SIZE=5>db</B></FONT><FONT FACE="Times" SIZE=5> directive.</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P><B><P ALIGN="JUSTIFY">Example: </P></B><P ALIGN="JUSTIFY"></P><DIR><DIR></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">reply&#9;&#9;db&#9;&#145;y&#146;</P><P ALIGN="JUSTIFY">prompt&#9;db&#9;&#145;Enter your favourite colour: &#146;, 0</P><P ALIGN="JUSTIFY">colour&#9;db&#9;80 dup(?)</P><P ALIGN="JUSTIFY">i&#9;&#9;db&#9;20</P><P ALIGN="JUSTIFY">k&#9;&#9;db&#9;?</P><P ALIGN="JUSTIFY">num&#9;&#9;dw&#9;4000</P><P ALIGN="JUSTIFY">large&#9;&#9;dd&#9;50000</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P></DIR></DIR></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY">reply</FONT><FONT FACE="Times" SIZE=5> is defined as a character variable, which is initialised to </FONT><FONT FACE="Courier" SIZE=5>&#145;y&#146;</FONT><FONT FACE="Times" SIZE=5>. </P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY">prompt</FONT><FONT FACE="Times" SIZE=5> is defined as a string, terminated by the Null character. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The definition of the variable </FONT><FONT FACE="Courier" SIZE=5>colour</FONT><FONT FACE="Times" SIZE=5> demonstrates how to declare an <B>array</B> of characters of size 80, which contains undefined values. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The purpose of </FONT><FONT FACE="Courier" SIZE=5>dup</FONT><FONT FACE="Times" SIZE=5> is to tell the assembler to duplicate or repeat the data definition directive a specific number of times, in this case </FONT><FONT FACE="Courier" SIZE=5>80 dup</FONT><FONT FACE="Times" SIZE=5> specifies that 80 bytes of storage are to be set aside since </FONT><FONT FACE="Courier" SIZE=5>dup</FONT><FONT FACE="Times" SIZE=5> is used with the </FONT><FONT FACE="Courier" SIZE=5>db</FONT><FONT FACE="Times" SIZE=5> directive. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=5>(?)</FONT><FONT FACE="Times" SIZE=5> with the </FONT><FONT FACE="Courier" SIZE=5>dup</FONT><FONT FACE="Times" SIZE=5> means that storage allocated by the directive is unitialised or undefined. </P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY">i</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>k</FONT><FONT FACE="Times" SIZE=5> are byte sized variables, where </FONT><FONT FACE="Courier" SIZE=5>i</FONT><FONT FACE="Times" SIZE=5> is initialised to </FONT><FONT FACE="Courier" SIZE=5>20</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>k</FONT><FONT FACE="Times" SIZE=5> is left undefined. </P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY">num</FONT><FONT FACE="Times" SIZE=5> is a 16-bit variable, initialised to </FONT><FONT FACE="Courier" SIZE=5>4000</FONT><FONT FACE="Times" SIZE=5> and the variable </FONT><FONT FACE="Courier" SIZE=5>large</FONT><FONT FACE="Times" SIZE=5> is a 32-bit variable, initialised to </FONT><FONT FACE="Courier" SIZE=5>15000</FONT><FONT FACE="Times" SIZE=5>.</P><P ALIGN="JUSTIFY"></P><P>&nbsp;</P><B><P ALIGN="JUSTIFY">Indirect Addressing</P></B><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Given that we have defined a string variable <B>message</B> as</FONT><FONT FACE="Courier" SIZE=5> </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">message db &#145;Hello&#146;,0,</FONT><FONT FACE="Times" SIZE=5> </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">an important feature is that the characters are <B>stored in consecutive memory locations</B>. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">If the </FONT><FONT FACE="Courier" SIZE=5>&#145;H&#146;</FONT><FONT FACE="Times" SIZE=5> is in location </FONT><FONT FACE="Courier" SIZE=5>1024</FONT><FONT FACE="Times" SIZE=5>, then </FONT><FONT FACE="Courier" SIZE=5>&#145;e&#146;</FONT><FONT FACE="Times" SIZE=5> will be in location </FONT><FONT FACE="Courier" SIZE=5>1025</FONT><FONT FACE="Times" SIZE=5>, </FONT><FONT FACE="Courier" SIZE=5>&#145;l&#146;</FONT><FONT FACE="Times" SIZE=5> will be in location </FONT><FONT FACE="Courier" SIZE=5>1026</FONT><FONT FACE="Times" SIZE=5> and so on. A technique known as <B>indirect addressing</B> may be used to access the elements of the array. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Indirect addressing allows us store the address of a location in a register and use this register to access the value stored at that location. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">This means that we can store the address of the string in a register and access the first character of the string via the register. If we increment the register contents by 1, we can access the next character of the string. By continuing to increment the register, we can access each character of the string, in turn, processing it as we see fit. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Figure 1 illustrates how indirect addressing operates, using register </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> to contain the address of a string </FONT><FONT FACE="Courier" SIZE=5>&quot;Hello&quot;</FONT><FONT FACE="Times" SIZE=5> in memory. Here, register </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> has the value </FONT><FONT FACE="Courier" SIZE=5>1024</FONT><FONT FACE="Times" SIZE=5> which is the address of the first character in the string. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Another way of phrasing this is to say that </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> <B>points</B> to the first character in the string. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">In 8086 assembly language we denote this by enclosing </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> in square brackets: </FONT><B><FONT FACE="Courier" SIZE=5>[bx]</B></FONT><FONT FACE="Times" SIZE=5>, which reads as the value <B>pointed to</B> by </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5>, i.e. <B>the contents of the location whose address is stored in the </FONT><FONT FACE="Courier" SIZE=5>bx </FONT><FONT FACE="Times" SIZE=5>register</B>.</P><P ALIGN="JUSTIFY"></P><DIR><DIR></FONT><FONT FACE="Times"><P ALIGN="JUSTIFY"><IMG SRC="Image27.gif" WIDTH=358 HEIGHT=219></P><P ALIGN="JUSTIFY"></P></DIR></DIR></FONT><B><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">Figure 1: </B>Using the </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> register for indirect addressing</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">The first character of the string can be accessed as follows:</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;&#9;cmp&#9;byte ptr [bx], 0&#9;; is this end of string?</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">This instruction compares the character (indicated by </FONT><FONT FACE="Courier" SIZE=5>byte</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>ptr</FONT><FONT FACE="Times" SIZE=5>) pointed to by </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> with 0. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">How do we store the address of the string in </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> in the first place? The special operator </FONT><B><FONT FACE="Courier" SIZE=5>offset</B></FONT><FONT FACE="Times" SIZE=5> allows us specify the address of a memory variable. For example, the instruction:</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;mov&#9;bx, offset message</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">will store the <B>address</B> of the variable </FONT><FONT FACE="Courier" SIZE=5>message</FONT><FONT FACE="Times" SIZE=5> in </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5>. We can then use </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> to access the variable </FONT><FONT FACE="Courier" SIZE=5>message</FONT><FONT FACE="Times" SIZE=5>. </P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">Example:</B> The following code fragment illustrates the use of indirect addressing. It is a loop to count the number of characters in a string terminated by the Null character (ASCII 0). It uses the </FONT><FONT FACE="Courier" SIZE=5>cx</FONT><FONT FACE="Times" SIZE=5> register to store the number of characters in the string.</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">message&#9;&#9;db&#9;&#9;&#145;Hello&#146;, 0</P><P ALIGN="JUSTIFY">.......</P><P ALIGN="JUSTIFY">........</P><P ALIGN="JUSTIFY">&#9;mov&#9;cx, 0&#9;&#9;&#9;&#9;; cx stores number of characters</P><P ALIGN="JUSTIFY">&#9;mov&#9;bx, offset message&#9;; store address of message in bx</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">begin:&#9;</P><P ALIGN="JUSTIFY">&#9;&#9;cmp&#9;byte ptr [bx], 0&#9;; is this end of string?</P><P ALIGN="JUSTIFY">&#9;&#9;je&#9;fin&#9;&#9;&#9;&#9;; if yes goto Finished</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;inc &#9;cx&#9;&#9;&#9;; cx = cx + 1</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;inc&#9;bx&#9;&#9;&#9;; bx points to next character</P><P ALIGN="JUSTIFY">&#9;&#9;jmp begin</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;&#9;&#9;; cx now contains the # of </P><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;&#9;&#9;; characters in message</P><P ALIGN="JUSTIFY">fin:</P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">The label </FONT><FONT FACE="Courier" SIZE=5>begin</FONT><FONT FACE="Times" SIZE=5> indicates the beginning of the loop to count the characters. After executing the </FONT><FONT FACE="Courier" SIZE=5>mov</FONT><FONT FACE="Times" SIZE=5> instruction, register </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> contains the address of the first character in the string. We compare this value with </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> and if the value is not </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>, we count it by incrementing </FONT><FONT FACE="Courier" SIZE=5>cx</FONT><FONT FACE="Times" SIZE=5>. We then increment </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> so that it now points to the next character in the string. We repeat this process until we reach the </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> character which terminates the string. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P><B><P ALIGN="JUSTIFY">Note</B>: If you omit the 0 character when defining the string, the above program will fail. Why? The reason is that the loop continues to execute, until </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> points to a memory location containing 0. If 0 has been omitted from the definition of message, then we do not know when, if ever, the loop will terminate. This is the same as an array subscript out of bounds error in a high level language.</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The form of indirect addressing described here is called <B>register indirect addressing</B> because a register is used store the indirect address.</P><P>&nbsp;</P><B><P ALIGN="JUSTIFY">String I/O</P></B><P ALIGN="JUSTIFY">In programming languages such as C, strings are terminated by the </FONT><FONT FACE="Courier" SIZE=5>&#145;\0&#146;</FONT><FONT FACE="Times" SIZE=5> character. We adopt the same convention. This method of terminating a string has an advantage over that used for the </FONT><FONT FACE="Courier" SIZE=5>puts</FONT><FONT FACE="Times" SIZE=5> subprogram defined earlier, where the &#145;$&#145; character is used to terminate a string. The use of the value 0 to terminate a string means that a string may contain the &#145;$&#146; character which can then be displayed, since &#145;$&#146; cannot be displayed by </FONT><FONT FACE="Courier" SIZE=5>puts</FONT><FONT FACE="Times" SIZE=5>. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">We use this indirect addressing in the implementation of two subprograms for reading and displaying strings:  </FONT><FONT FACE="Courier" SIZE=5>get_str</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>put_str</P></FONT><FONT FACE="Times" SIZE=6><P ALIGN="JUSTIFY"></P></FONT><B><FONT FACE="Times" SIZE=5><P>Example 3.42: </B>Read colour entered by the user and display a suitable message, using </FONT><FONT FACE="Courier" SIZE=5>get_str</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>put_str</FONT><FONT FACE="Times" SIZE=5>.</P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">; colour.asm: Prompt user to enter a colour and display a message</P><P ALIGN="JUSTIFY">; Author:&#9;Joe Carthy</P><P ALIGN="JUSTIFY">; Date:&#9;March 1994</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;.model small</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;.stack 256</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">CR&#9;&#9;equ&#9;&#9;13d</P><P ALIGN="JUSTIFY">LF&#9;&#9;equ&#9;&#9;10d</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">; string definitions: note 0 terminator</P><P ALIGN="JUSTIFY">&#9;&#9;.data</P><P ALIGN="JUSTIFY">msg1&#9;&#9;db&#9;&#145;Enter your favourite colour: &#145;, 0</P><P ALIGN="JUSTIFY">msg2&#9;&#9;db&#9;CR, LF,&#145;Yuk ! I hate &#145;, 0</P><P ALIGN="JUSTIFY">colour&#9;db&#9;80 dup (0)</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;.code</P><P ALIGN="JUSTIFY">start:</P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, @data</P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ds, ax</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, offset msg1</P><P ALIGN="JUSTIFY">&#9;&#9;call&#9;put_str&#9;&#9;&#9;; display prompt</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, offset colour</P><P ALIGN="JUSTIFY">&#9;&#9;call&#9;get_str&#9;&#9;&#9;; read colour</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, offset msg2</P><P ALIGN="JUSTIFY">&#9;&#9;call&#9;put_str&#9;&#9;&#9;; display msg2</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, offset colour</P><P ALIGN="JUSTIFY">&#9;&#9;call&#9;put_str&#9;&#9;&#9;; display colour entered by user</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, 4c00h</P><P ALIGN="JUSTIFY">&#9;&#9;int &#9;&#9;21h&#9;&#9;&#9;; finished, back to dos</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">&nbsp;</P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">put_str:&#9;&#9;&#9;&#9;; display string terminated by 0 </P><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;&#9;; whose address is in ax</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;push&#9;ax&#9;; save registers</P><P ALIGN="JUSTIFY">&#9;&#9;push&#9;bx&#9;</P><P ALIGN="JUSTIFY">&#9;&#9;push&#9;cx</P><P ALIGN="JUSTIFY">&#9;&#9;push&#9;dx</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;bx, ax&#9;&#9;&#9;; store address in bx</P><P>&#9;&#9;mov&#9;al, byte ptr [bx]&#9;</FONT><FONT FACE="Courier" SIZE=3>; al = first char in string</P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">put_loop:&#9;cmp&#9;al, 0&#9;&#9;&#9;&#9;; al == 0 ?</P><P ALIGN="JUSTIFY">&#9;&#9;je&#9;put_fin&#9;&#9;&#9;; while al != 0</P><P ALIGN="JUSTIFY">&#9;&#9;call&#9;putc&#9;&#9;&#9;&#9;; display character</P><P ALIGN="JUSTIFY">&#9;&#9;inc&#9;bx&#9;&#9;&#9;&#9;; bx = bx + 1</P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;al, byte ptr [bx]&#9;; al = next char in string</P><P ALIGN="JUSTIFY">&#9;&#9;jmp&#9;put_loop&#9;&#9;&#9;; repeat loop test</P><P ALIGN="JUSTIFY">put_fin:&#9;&#9;</P><P ALIGN="JUSTIFY">&#9;&#9;pop&#9;dx&#9;&#9;&#9;&#9;; restore registers</P><P ALIGN="JUSTIFY">&#9;&#9;pop&#9;cx</P><P ALIGN="JUSTIFY">&#9;&#9;pop&#9;bx</P><P ALIGN="JUSTIFY">&#9;&#9;pop&#9;ax</P><P ALIGN="JUSTIFY">&#9;&#9;ret</P></FONT><FONT FACE="Times" SIZE=5></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">get_str:&#9;&#9;&#9;; read string terminated by CR into array</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;; whose address is in ax</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;&#9;push&#9;ax&#9;; save registers</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;push&#9;bx&#9;</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;push&#9;cx</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;push&#9;dx</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;&#9;mov&#9;bx, ax</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;&#9;call&#9;getc&#9;&#9;&#9;; read first character</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;mov&#9;byte ptr [bx], al&#9;; In C: str[i] = al</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">get_loop:&#9;&#9;cmp&#9;al, 13&#9;&#9;; al == CR ?</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;je&#9;get_fin&#9;&#9;;while al != CR</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;&#9;inc&#9;bx&#9;&#9;&#9;; bx = bx + 1</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;call&#9;getc&#9;&#9;&#9;; read next character</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;mov&#9;byte ptr [bx], al&#9;; In C: str[i] = al</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;jmp get_loop&#9;&#9;; repeat loop test</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">get_fin:&#9;&#9;mov&#9;byte ptr [bx], 0&#9;; terminate string with 0</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;&#9;pop&#9;dx&#9;&#9;&#9;; restore registers</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;pop&#9;cx</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;pop&#9;bx</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;pop&#9;ax</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;ret</P></FONT><FONT FACE="Times" SIZE=5></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">putc:&#9;&#9;&#9;&#9;; display character in al</P><P ALIGN="JUSTIFY">&#9;&#9;push&#9;ax&#9;; save ax</P><P ALIGN="JUSTIFY">&#9;&#9;push&#9;bx&#9;; save bx </P><P ALIGN="JUSTIFY">&#9;&#9;push&#9;cx&#9;; save cx</P><P ALIGN="JUSTIFY">&#9;&#9;push&#9;dx&#9;; save dx</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;dl, al</P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ah, 2h</P><P ALIGN="JUSTIFY">&#9;&#9;int&#9;21h</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;pop&#9;dx&#9;; restore dx</P><P ALIGN="JUSTIFY">&#9;&#9;pop&#9;cx&#9;; restore cx</P><P ALIGN="JUSTIFY">&#9;&#9;pop&#9;bx&#9;; restore bx</P><P ALIGN="JUSTIFY">&#9;&#9;pop&#9;ax&#9;; restore ax</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;ret</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">getc:&#9;&#9;&#9;&#9;; read character into al</P><P ALIGN="JUSTIFY">&#9;&#9;push&#9;bx&#9;; save bx </P><P ALIGN="JUSTIFY">&#9;&#9;push&#9;cx&#9;; save cx</P><P ALIGN="JUSTIFY">&#9;&#9;push&#9;dx&#9;; save dx</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov ah, 1h</P><P ALIGN="JUSTIFY">&#9;&#9;int 21h</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;pop&#9;dx&#9;; restore dx</P><P ALIGN="JUSTIFY">&#9;&#9;pop&#9;cx&#9;; restore cx</P><P ALIGN="JUSTIFY">&#9;&#9;pop&#9;bx&#9;; restore bx</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;ret</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;end start</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">This program produces as output:</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">Enter your favourite colour: <B>yellow</P></B><P ALIGN="JUSTIFY">Yuk ! I hate yellow</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P>&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><B><P ALIGN="JUSTIFY">Reading and Displaying Numbers</P></B><P ALIGN="JUSTIFY">See Chapter 3 of textbook for implementation details</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">We use </FONT><FONT FACE="Courier" SIZE=5>getn</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>putn</FONT><FONT FACE="Times" SIZE=5> to read and display numbers: </P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY">getn: </FONT><FONT FACE="Times" SIZE=5>reads a number from the keyboard and returns it in the ax register</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY">putn: </FONT><FONT FACE="Times" SIZE=5> displays the number in the ax register</P></FONT><FONT FACE="Times" SIZE=6><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">Example: Write a program to read two numbers, add them and display the result. </P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">; calc.asm: Read and sum two numbers. Display result.</P><P ALIGN="JUSTIFY">; Author:&#9;Joe Carthy</P><P ALIGN="JUSTIFY">; Date:&#9;March 1994</P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;&#9;.model small</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;.stack 256</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">CR&#9;&#9;equ&#9;&#9;13d</P><P ALIGN="JUSTIFY">LF&#9;&#9;equ&#9;&#9;10d</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;.data</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">prompt1&#9;db&#9;&#145;Enter first number: &#146;, 0</P><P ALIGN="JUSTIFY">prompt2&#9;db&#9;CR, LF,&#145;Enter second number:&#146;,0</P><P ALIGN="JUSTIFY">result&#9;db&#9;CR, LF &#145;The sum is&#146;, 0</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">num1&#9;&#9;dw&#9;?</P><P ALIGN="JUSTIFY">num2&#9;&#9;dw&#9;?&#9;</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&#9;&#9;.code</P><P ALIGN="JUSTIFY">start:</P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, @data</P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ds, ax</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, offset prompt1</P><P ALIGN="JUSTIFY">&#9;&#9;call&#9;put_str&#9;&#9;&#9;&#9;; display prompt1</P><P ALIGN="JUSTIFY">&#9;&#9;call&#9;getn&#9;&#9;&#9;&#9;; read first number</P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;num1, ax</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, offset prompt2</P><P ALIGN="JUSTIFY">&#9;&#9;call&#9;put_str&#9;&#9;&#9;&#9;; display prompt2</P><P ALIGN="JUSTIFY">&#9;&#9;call&#9;getn&#9;&#9;&#9;&#9;; read second number</P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;num2, ax</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, offset result</P><P ALIGN="JUSTIFY">&#9;&#9;call&#9;put_str&#9;&#9;&#9;&#9;; display result message</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, num1&#9;&#9;&#9;; ax = num1</P><P ALIGN="JUSTIFY">&#9;&#9;add&#9;ax, num2&#9;&#9;&#9;; ax = ax + num2</P><P ALIGN="JUSTIFY">&#9;&#9;call&#9;putn&#9;&#9;&#9;&#9;; display sum</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;ax, 4c00h</P><P ALIGN="JUSTIFY">&#9;&#9;int &#9;21h&#9;&#9;&#9;&#9;; finished, back to dos</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&#9;&lt;definitions of getn, putn, put_str, get_str, getc, putc go here&gt;</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;&#9;end start</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">Running the above program produces:</P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY">Enter first number: <B>8</P></B><P>Enter second number: <B>6</P></B><P>The sum is 14</P></FONT><B><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">More about the Stack</P></B><P ALIGN="JUSTIFY">A <B>stack</B> is an <B>area of memory</B> which is used for storing data on a temporary basis. In a typical computer system the memory is logically partitioned into separate areas. Your program code is stored in one such area, your variables may be in another such area and another area is used for the stack. Figure 2 is a crude illustration of how memory might be allocated to a user program running.</P><P ALIGN="JUSTIFY"></P><DIR><DIR><P ALIGN="JUSTIFY"><IMG SRC="Image28.gif" WIDTH=381 HEIGHT=279></P><P ALIGN="JUSTIFY"></P></DIR></DIR><B><P ALIGN="JUSTIFY">Figure 2: </B>Memory allocation: User programs share memory with the Operating System software</P><B><P ALIGN="JUSTIFY"></P></B><P ALIGN="JUSTIFY">The area of memory with addresses near 0 is called low memory, while high memory refers to the area of memory near the highest address. The area of memory used for your program code is fixed, i.e. once the code is loaded into memory it does not grow or shrink. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The stack on the other hand may require varying amounts of memory. The amount actually required depends on how the program uses the stack. Thus the size of the stack varies during program execution. We can store information on the stack and retrieve it later.  </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">One of the most common uses of the stack is in the implementation of the subprogram facility. This usage is transparent to the programmer, i.e. the programmer does not have to explicitly access the stack. The instructions to call a subprogram and to return from a subprogram automatically access the stack. They do this in order to return to the correct place in your program when the subprogram is finished. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The point in your program where control returns after a subprogram finishes is called the<B> return address.</B> The return address of a subprogram is placed on the stack by the </FONT><FONT FACE="Courier" SIZE=5>call</FONT><FONT FACE="Times" SIZE=5> instruction. When the subprogram finishes, the </FONT><FONT FACE="Courier" SIZE=5>ret</FONT><FONT FACE="Times" SIZE=5> instruction retrieves the return address from the stack and transfers control to that location. The stack may also be used to pass information to subprograms and to return information from subprograms, i.e. as a mechanism for handling high level language parameters.</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Conceptually a stack as its name implies is a <B>stack of data elements</B>. The size of the elements depends on the processor and for example, may be 1 byte, 2 bytes or 4 bytes. We will ignore this for the moment. We can illustrate a stack as in Figure 3:</P><P ALIGN="JUSTIFY"></P><DIR><DIR><DIR><DIR><P ALIGN="JUSTIFY"><IMG SRC="Image29.gif" WIDTH=351 HEIGHT=237></P></FONT><FONT FACE="Times"><P ALIGN="JUSTIFY"></P></DIR></DIR></DIR></DIR></FONT><B><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">Figure 3: </B>Simple model of the stack</P><B><P ALIGN="JUSTIFY"></P></B><P ALIGN="JUSTIFY">To use the stack, the processor must keep track of where items are stored on it. It does this by using the <B>stack pointer</B> (</FONT><B><FONT FACE="Courier" SIZE=5>sp</B></FONT><FONT FACE="Times" SIZE=5>) register. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">This is one of the processor's special registers. It points to the <B>top</B> of the stack, i.e. its contains the address of the stack memory element containing the value last placed on the stack. When we place an element on the stack, the stack pointer contains the address of that element on the stack. If we place a number of elements on the stack, the stack pointer will always point to the last element we placed on the stack. When retrieving elements from the stack we retrieve them in reverse order. This will become clearer when we write some stack manipulation programs.</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">There are two basic stack operations which are used to manipulate the stack usually called <B>push</B> and <B>pop</B>. The 8086 </FONT><FONT FACE="Courier" SIZE=5>push</FONT><FONT FACE="Times" SIZE=5> instruction places (pushes) a value on the stack. The stack pointer is left pointing at the value pushed on the stack. For example, if </FONT><FONT FACE="Courier" SIZE=5>ax </FONT><FONT FACE="Times" SIZE=5>contains the number </FONT><FONT FACE="Courier" SIZE=5>123</FONT><FONT FACE="Times" SIZE=5>, then the following instruction:</P><P ALIGN="JUSTIFY"></P></FONT><B><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;&#9;&#9;push&#9;ax</P></B></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">will cause the value of </FONT><FONT FACE="Courier" SIZE=5>ax</FONT><FONT FACE="Times" SIZE=5> to be stored on the stack. In this case the number </FONT><FONT FACE="Courier" SIZE=5>123</FONT><FONT FACE="Times" SIZE=5> is stored on the stack and </FONT><FONT FACE="Courier" SIZE=5>sp</FONT><FONT FACE="Times" SIZE=5> <B>points</B> to the location on the stack where </FONT><FONT FACE="Courier" SIZE=5>123</FONT><FONT FACE="Times" SIZE=5> is stored. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The 8086 </FONT><FONT FACE="Courier" SIZE=5>pop</FONT><FONT FACE="Times" SIZE=5> instruction is used to retrieve a value previously placed on the stack. The stack pointer is left pointing at the next element on the stack. Thus </FONT><FONT FACE="Courier" SIZE=5>pop</FONT><FONT FACE="Times" SIZE=5> conceptually removes the value from the stack. Having stored a value on the stack as above, we can retrieve it by:</P><P ALIGN="JUSTIFY"></P></FONT><B><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;&#9;&#9;pop&#9;ax</P></B></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">which transfers the data from the top of the stack to </FONT><FONT FACE="Courier" SIZE=5>ax</FONT><FONT FACE="Times" SIZE=5>, (or any register) in this case the number </FONT><FONT FACE="Courier" SIZE=5>123</FONT><FONT FACE="Times" SIZE=5> is transferred. Information is stored on the stack starting from high memory locations. As we place data on the stack, the stack pointer points to successively lower memory locations. We say that the stack grows downwards.<B> </B>If we assume that the top of the stack is location </FONT><FONT FACE="Courier" SIZE=5>1000</FONT><FONT FACE="Times" SIZE=5> (</FONT><FONT FACE="Courier" SIZE=5>sp</FONT><FONT FACE="Times" SIZE=5> contains </FONT><FONT FACE="Courier" SIZE=5>1000</FONT><FONT FACE="Times" SIZE=5>) then the operation of </FONT><FONT FACE="Courier" SIZE=5>push ax</FONT><FONT FACE="Times" SIZE=5> is as follows. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Firstly, </FONT><FONT FACE="Courier" SIZE=5>sp</FONT><FONT FACE="Times" SIZE=5> is decremented by the size of the element (2 bytes for the 8086) to be pushed on the stack. Then the value of </FONT><FONT FACE="Courier" SIZE=5>ax</FONT><FONT FACE="Times" SIZE=5> is copied to the location pointed to by </FONT><FONT FACE="Courier" SIZE=5>sp</FONT><FONT FACE="Times" SIZE=5>, i.e. </FONT><FONT FACE="Courier" SIZE=5>998</FONT><FONT FACE="Times" SIZE=5> in this case. If we then assign </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> the value </FONT><FONT FACE="Courier" SIZE=5>212</FONT><FONT FACE="Times" SIZE=5> and carry out a </FONT><FONT FACE="Courier" SIZE=5>push bx </FONT><FONT FACE="Times" SIZE=5>operation, </FONT><FONT FACE="Courier" SIZE=5>sp</FONT><FONT FACE="Times" SIZE=5> is again decremented by two, giving it the value </FONT><FONT FACE="Courier" SIZE=5>996</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>212</FONT><FONT FACE="Times" SIZE=5> is stored at this location on the stack. We now have two values on the stack.</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">As mentioned earlier, if we now retrieve these values, we encounter the fundamental feature of any stack mechanism. Values are retrieved in <B>reverse order. </B>This means that the last item placed on the stack, is the first item to be retrieved. We call such a process a <B>Last-In-First-Out</B> process or a <B>LIFO</B> process. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">So, if we now carry out a </FONT><FONT FACE="Courier" SIZE=5>pop ax</FONT><FONT FACE="Times" SIZE=5> operation, </FONT><FONT FACE="Courier" SIZE=5>ax</FONT><FONT FACE="Times" SIZE=5> gets as its value </FONT><FONT FACE="Courier" SIZE=5>212</FONT><FONT FACE="Times" SIZE=5>, i.e. the last value pushed on the stack. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">If we now carry out a </FONT><FONT FACE="Courier" SIZE=5>pop bx</FONT><FONT FACE="Times" SIZE=5> operation, </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> gets as its value </FONT><FONT FACE="Courier" SIZE=5>123</FONT><FONT FACE="Times" SIZE=5>, the second last value pushed on the stack. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Hence, the operation of </FONT><FONT FACE="Courier" SIZE=5>pop</FONT><FONT FACE="Times" SIZE=5> is to copy a value from the top of the stack, as pointed to by </FONT><FONT FACE="Courier" SIZE=5>sp</FONT><FONT FACE="Times" SIZE=5> and to increment </FONT><FONT FACE="Courier" SIZE=5>sp</FONT><FONT FACE="Times" SIZE=5> by 2 so that it now points to the previous value on the stack. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">We can push the value of any register or memory variable on the stack. We can retrieve a value from the stack and store it in any register or a memory variable. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The above example is illustrated in Figure 4 (steps (1) to (4) correspond to the states of the stack and stack pointer after each instruction).</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Note: For the 8086, we can <B>only push 16-bit items</B> onto the stack e.g. any register.</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The following are ILLEGAL: &#9;push al</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;&#9;&#9;pop bh</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY"><IMG SRC="Image30.gif" WIDTH=479 HEIGHT=527></P></FONT><FONT FACE="Times"><P ALIGN="JUSTIFY"></P></FONT><B><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">Figure 4: </B>LIFO nature of push and pop</P><B><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P></B><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><B><P ALIGN="JUSTIFY">Example: </B>Using the stack, swap the values of the </FONT><FONT FACE="Courier" SIZE=5>ax</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> registers, so that </FONT><FONT FACE="Courier" SIZE=5>ax</FONT><FONT FACE="Times" SIZE=5> now contains what </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> contained and </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> contains what </FONT><FONT FACE="Courier" SIZE=5>ax</FONT><FONT FACE="Times" SIZE=5> contained. (This is not the most efficient way to exchange the contents of two variables). To carry out this operation, we need at least one temporary variable:</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Version 1<B>:</P></B><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;push&#9;ax&#9;&#9;&#9;; Store ax on stack</P><P ALIGN="JUSTIFY">&#9;push&#9;bx&#9;&#9;&#9;; Store bx on stack</P><P ALIGN="JUSTIFY">&#9;pop&#9;ax&#9;&#9;&#9;; Copy last value on stack to ax</P><P ALIGN="JUSTIFY">&#9;pop&#9;bx&#9;&#9;&#9;; Copy first value to bx</P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">The above solution stores both </FONT><FONT FACE="Courier" SIZE=5>ax</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> on the stack and utilises the LIFO nature of the stack to retrieve the values in reverse order, thus swapping them in this example. We really only need to store one of the values on the stack, so the following is a more efficient solution.</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Version 2:<B> </P></B><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;push&#9;ax&#9;&#9;&#9;; Store ax on stack</P><P ALIGN="JUSTIFY">&#9;mov&#9;ax, bx&#9;&#9;; Copy bx to ax</P><P ALIGN="JUSTIFY">&#9;pop&#9;bx&#9;&#9;&#9;; Copy old ax from stack</P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">When using the stack, the number of items pushed on should equal the number of items popped off. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">This is vital if the stack is being used inside a subprogram. This is because, when a subprogram is called its return address is pushed on the stack. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">If, inside the subprogram, you push something on the stack and do not remove it, the return instruction will retrieve the item you left on the stack instead of the return address. This means that your subprogram cannot return to where it was called from and it will most likely crash (unless you were very clever about what you left on the stack!).<B> </P><P ALIGN="JUSTIFY"></P></B><P ALIGN="JUSTIFY">&nbsp;</P><B><P ALIGN="JUSTIFY">Format of Assembly Language Instructions</P></B><P ALIGN="JUSTIFY">The format of assembly language instructions is relatively standard. The <B>general format</B> of an instruction is (where square brackets <B>[]</B> indicate the <B>optional</B> fields) as follows:</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY">[Label]   Operation   [Operands]    [; Comment]</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The instruction may be treated as being composed of four <B>fields</B>. All four fields need <B>not</B> be present in every instruction, as we have seen from the examples already presented. Unless there is only a comment field, the <B>operation</B> <B>field</B> is <B>always</B> necessary. The label and the operand fields may or may not be required depending on the operation field.</P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">Example: </B>Examples of instructions with varying numbers of fields.</P><B><P ALIGN="JUSTIFY"></P></B></FONT><FONT FACE="Times" SIZE=4><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;<B>Note</P></B></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">L1:&#9;cmp bx, cx&#9; ; Compare bx with cx </FONT><B><I><FONT FACE="Times">all fields present</P></B></I><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;add ax, 25</FONT><FONT FACE="Times">&#9;&#9;&#9;&#9;&#9;<B><I>operation and</B> <B>2 operands</P></B></I><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;</FONT><FONT FACE="Courier">inc bx</FONT><FONT FACE="Times">&#9;&#9;&#9;&#9;&#9;<B><I>operation and</B> <B>1 operand</I> </P></B><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&#9;</FONT><FONT FACE="Courier">ret</FONT><FONT FACE="Times">&#9;&#9;&#9;&#9;&#9;&#9;<B><I>operation field only</I> </P></B><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">; Comment: whatever you wish !!</FONT><FONT FACE="Times">&#9;<B><I>comment field only</P></I></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P></B><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><B><P ALIGN="JUSTIFY">Bit Manipulation</P></B><P ALIGN="JUSTIFY">One of the features of assembly language programming is that you can access the individual bits of a byte (word or long word). </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">You can <B>set</B> bits (give them a value of </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5>), <B>clear</B> them (give them a value of </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>), <B>complement</B> them (change </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> to </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5> or </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5> to </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>), and <B>test</B> if they have a particular value. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">These operations are essential when writing subprograms to control devices such as printers, plotters and disk drives. Subprograms that control devices are often called <B>device</B> <B>drivers</B>. In such subprograms, it is often necessary to set particular bits in a register associated with the device, in order to operate the device. The instructions to operate on bits are called <B>logical</B> instructions.</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Under normal circumstances programmers rarely need concern themselves with bit operations. In fact most high-level languages do not provide bit manipulation operations. (The C language is a notable exception). Another reason for manipulating bits is to make programs more efficient. By this we usually mean one of two things: the program is smaller in size and so requires less RAM or the program runs faster. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P><B><P ALIGN="JUSTIFY">The Logical Instructions: </B></FONT><FONT FACE="Courier" SIZE=5>and,</FONT><FONT FACE="Times" SIZE=5>  </FONT><FONT FACE="Courier" SIZE=5>or,</FONT><FONT FACE="Times" SIZE=5>  </FONT><FONT FACE="Courier" SIZE=5>xor,</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>not</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">As stated above, the logical instructions allow us operate on the bits of an operand. The operand may be a byte (8 bits), a word (16 bits) a long word (32 bits). We will concentrate on byte sized operands, but the instructions operate on word operands in exactly the same fashion.</P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">Clearing Bits: </B></FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> instruction</P><P ALIGN="JUSTIFY">A bit </FONT><B><FONT FACE="Courier" SIZE=5>and</B></FONT><FONT FACE="Times" SIZE=5> operation compares two bits and sets the result to </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> if either of the bits is </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>.</P><P ALIGN="JUSTIFY">e.g. </P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;1</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">and</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">0</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">returns</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">0</P><P ALIGN="JUSTIFY">&#9;0</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">and</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">1</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">returns</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">0</P><P ALIGN="JUSTIFY">&#9;0</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">and</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">0</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">returns</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">0</P><P ALIGN="JUSTIFY">&#9;1</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">and</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">1</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">returns</FONT><FONT FACE="Times"> </FONT><FONT FACE="Courier">1 </P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> instruction carries out the </FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> operation on all of the bits of the source operand with all of the bits of the destination operand, storing the result in the destination operand (like the arithmetic instructions such as </FONT><FONT FACE="Courier" SIZE=5>add</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>sub</FONT><FONT FACE="Times" SIZE=5>). </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The operation </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5> always results in </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> regardless of the value of </FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5> (</FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5> or </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>). This means that we can use the </FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> instruction to clear a specified bit or collection of bits in an operand. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">If we wish to clear, say bit 5, of an 8-bit operand, we </FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> the operand with the value </FONT><FONT FACE="Courier" SIZE=5>1101</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>1111</FONT><FONT FACE="Times" SIZE=5>, i.e. a value with bit </FONT><FONT FACE="Courier" SIZE=5>5</FONT><FONT FACE="Times" SIZE=5> set to </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> and all other values set to </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5>. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">This results in bit </FONT><FONT FACE="Courier" SIZE=5>5</FONT><FONT FACE="Times" SIZE=5> of the 8-bit operand being cleared, with the other bits remaining unchanged, since </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5> always yields </FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5>. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">(Remember, when referring to a bit number, we count from bit </FONT><B><FONT FACE="Courier" SIZE=5>0</B></FONT><FONT FACE="Times" SIZE=5> upwards.)</P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">Example 4.1:</B> To clear bit </FONT><FONT FACE="Courier" SIZE=5>5</FONT><FONT FACE="Times" SIZE=5> of a byte we </FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> the byte with </FONT><FONT FACE="Courier" SIZE=5>1101</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>1111</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;mov&#9;al, 62h&#9;&#9;; al =&#9;&#9;0110 0010</P><P ALIGN="JUSTIFY">&#9;and&#9;al, 0dfh&#9;&#9;; and it with&#9;<U>1101 1111</P></U><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;&#9;; al is 42h&#9;0100 0010</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">[Note: You can use binary numbers directly in 8086 assembly language, e.g.</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;mov&#9;al, 01100010b</P><P ALIGN="JUSTIFY">&#9;and&#9;al, 11011111b</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">but it is easier to write them using their hexadecimal equivalents.]</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The value in the source operand, </FONT><FONT FACE="Courier" SIZE=5>0dfh</FONT><FONT FACE="Times" SIZE=5>, in this example, is called a <B>bit mask</B>. It specifies the bits in the destination operand that are to be changed. Using the </FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> instruction, any bit in the bit mask with value </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> will cause the corresponding bit in the destination operand to be cleared. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">In the ASCII codes of the lowercase letters, bit </FONT><FONT FACE="Courier" SIZE=5>5</FONT><FONT FACE="Times" SIZE=5> is always </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5>. The corresponding ASCII codes of the uppercase letters are identical except that bit </FONT><FONT FACE="Courier" SIZE=5>5</FONT><FONT FACE="Times" SIZE=5> is always </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>. Thus to convert a lowercase letter to uppercase we simply need to clear bit </FONT><FONT FACE="Courier" SIZE=5>5</FONT><FONT FACE="Times" SIZE=5> (i.e. set bit </FONT><FONT FACE="Courier" SIZE=5>5</FONT><FONT FACE="Times" SIZE=5> to </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>). This can be done using the </FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> instruction and an appropriate bit mask, i.e. </FONT><FONT FACE="Courier" SIZE=5>0dfh</FONT><FONT FACE="Times" SIZE=5>, as shown in the above example. The letter </FONT><FONT FACE="Courier" SIZE=5>&#145;b&#146;</FONT><FONT FACE="Times" SIZE=5> has ASCII code </FONT><FONT FACE="Courier" SIZE=5>62h</FONT><FONT FACE="Times" SIZE=5>. We could rewrite Example 4.1 above as:</P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">Example B.1: </B>Converting a lowercase letter to its uppercase equivalent:</P><B><P ALIGN="JUSTIFY"></P></B></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;mov&#9;al, &#145;b&#146;&#9;&#9;; al = &#145;b&#146;(= 98d or 62h)&#9;0110 0010</P><P ALIGN="JUSTIFY">&#9;and&#9;al, 0dfh&#9;&#9;; mask = &#9;&#9;&#9;&#9;<U>1101 1111</P></U><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;&#9;</FONT><FONT FACE="Courier" SIZE=2>; al now = &#145;B&#146;(= 66d or 42h)&#9;</FONT><FONT FACE="Courier">0100 0010</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The bit mask </FONT><FONT FACE="Courier" SIZE=5>1101</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>1111</FONT><FONT FACE="Times" SIZE=5> when used with </FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> will always set bit </FONT><FONT FACE="Courier" SIZE=5>5</FONT><FONT FACE="Times" SIZE=5> to </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> leaving the remaining bits unchanged as illustrated below:</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;xxxx xxxx&#9;; destination bits</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;and&#9;<U>1101 1111</U>&#9;; and with mask bits</P><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;xx0x xxxx&#9;; result is that bit 5 is cleared</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">If the destination operand contains a lowercase letter, the result will be the corresponding uppercase equivalent. In effect, we have subtracted </FONT><FONT FACE="Courier" SIZE=5>32</FONT><FONT FACE="Times" SIZE=5> from the ASCII code of the lowercase letter which was the method we used in Chapter 3 for converting lowercase letters to their uppercase equivalents.</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P><B><P ALIGN="JUSTIFY">Setting Bits: </B></FONT><FONT FACE="Courier" SIZE=5>or</FONT><FONT FACE="Times" SIZE=5> instruction</P><P ALIGN="JUSTIFY">A bit </FONT><FONT FACE="Courier" SIZE=5>or</FONT><FONT FACE="Times" SIZE=5> operation compares two bits and sets the result to </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5> if either bit is set to </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5>.</P><P ALIGN="JUSTIFY">e.g. </P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;1 or 0 returns 1 </P><P ALIGN="JUSTIFY">&#9;0 or 1 returns 1 </P><P ALIGN="JUSTIFY">&#9;1 or 1 returns 1</P><P ALIGN="JUSTIFY">&#9;0 or 0 returns 0</P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=5>or</FONT><FONT FACE="Times" SIZE=5> instruction carries out an </FONT><FONT FACE="Courier" SIZE=5>or</FONT><FONT FACE="Times" SIZE=5> operation with all of the bits of the source and destination operands and stores the result in the destination operand. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=5>or</FONT><FONT FACE="Times" SIZE=5> instruction can be used to set bits to </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5> regardless of their current setting since </FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>or</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5> returns </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5> regardless of the value of </FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5> (</FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> or </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5>). </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">The bits set using the </FONT><FONT FACE="Courier" SIZE=5>or</FONT><FONT FACE="Times" SIZE=5> instruction are said to be <B>masked in</B>. </P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">Example: </B>Take the conversion of an uppercase letter to lowercase, the opposite of Example B.1 discussed above. Here, we need to <B>set</B> bit </FONT><FONT FACE="Courier" SIZE=5>5</FONT><FONT FACE="Times" SIZE=5> of the uppercase letter&#146;s ASCII code to </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5> so that it becomes lowercase and leave all other bits unchanged. The required mask is </FONT><FONT FACE="Courier" SIZE=5>0010 0000</FONT><FONT FACE="Times" SIZE=5> (</FONT><FONT FACE="Courier" SIZE=5>20h</FONT><FONT FACE="Times" SIZE=5>). If we store </FONT><FONT FACE="Courier" SIZE=5>&#145;A&#146;</FONT><FONT FACE="Times" SIZE=5> in </FONT><FONT FACE="Courier" SIZE=5>al</FONT><FONT FACE="Times" SIZE=5> then it can be converted to </FONT><FONT FACE="Courier" SIZE=5>&#145;a&#146;</FONT><FONT FACE="Times" SIZE=5> as follows:</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;mov&#9;al, &#145;A&#145;&#9;&#9;&#9;; al = &#145;A&#145; =&#9;0100 0001</P><P ALIGN="JUSTIFY">&#9;or&#9;al, 20h&#9;&#9;&#9;; or with&#9;&#9;<U>0010 0000</P></U><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;&#9;&#9;; gives al = &#145;a&#145;&#9;0110 0001</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">In effect, we have added </FONT><FONT FACE="Courier" SIZE=5>32</FONT><FONT FACE="Times" SIZE=5> to the uppercase ASCII code thus obtaining the lowercase ASCII code. </P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Before changing the case of a letter, it is important to verify that you have a letter in the variable you are working with. </P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">Exercises </P></B><P ALIGN="JUSTIFY">4.1 Specify the instructions and masks would you use to</P><P ALIGN="JUSTIFY">&#9;&#9;a) set bits </FONT><FONT FACE="Courier" SIZE=5>2</FONT><FONT FACE="Times" SIZE=5>, </FONT><FONT FACE="Courier" SIZE=5>3</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>4</FONT><FONT FACE="Times" SIZE=5> of the </FONT><FONT FACE="Courier" SIZE=5>ax</FONT><FONT FACE="Times" SIZE=5> register</P><P ALIGN="JUSTIFY">&#9;&#9;b) clear bits </FONT><FONT FACE="Courier" SIZE=5>4</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>7</FONT><FONT FACE="Times" SIZE=5> of the </FONT><FONT FACE="Courier" SIZE=5>bx</FONT><FONT FACE="Times" SIZE=5> register</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">4.2 How would </FONT><FONT FACE="Courier" SIZE=5>al</FONT><FONT FACE="Times" SIZE=5> be affected by the following instructions:</P><P ALIGN="JUSTIFY">&#9;&#9;(a) &#9;</FONT><FONT FACE="Courier">and&#9;al, 00fh</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">&#9;&#9;(b)&#9;</FONT><FONT FACE="Courier">and&#9;al, 0f0h</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">&#9;&#9;(c)&#9;</FONT><FONT FACE="Courier">or&#9;al, 00fh</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">&#9;&#9;(d)&#9;</FONT><FONT FACE="Courier">or&#9;al, 0f0h</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">4.3 Write subprograms </FONT><FONT FACE="Courier" SIZE=5>todigit</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>tocharacter</FONT><FONT FACE="Times" SIZE=5>, which convert a digit to its equivalent ASCII character code and vice versa. </P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY"></P></FONT><B><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">4.1.3 The </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5> instruction</P></B><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5> operation compares two bits and sets the result to </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5> if the bits are different.</P><P ALIGN="JUSTIFY">e.g.</P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;1 xor 0 returns 1</P><P ALIGN="JUSTIFY">&#9;0 xor 1 returns 1</P><P ALIGN="JUSTIFY">&#9;1 xor 1 returns 0</P><P ALIGN="JUSTIFY">&#9;0 xor 0 returns 0</P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5> instruction carries out the </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5> operation with its operands, storing the result in the destination operand.</P></FONT><FONT FACE="Courier" SIZE=5><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5> instruction can be used to <B>toggle</B> the value of specific bits (reverse them from their current settings). The bit mask to toggle particular bits should have </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5>&#146;s for any bit position you wish to toggle and </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>&#146;s for bits which are to remain unchanged. </P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">Example 4.7: </B>Toggle bits </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>, </FONT><FONT FACE="Courier" SIZE=5>1</FONT><FONT FACE="Times" SIZE=5> and </FONT><FONT FACE="Courier" SIZE=5>6</FONT><FONT FACE="Times" SIZE=5> of the value in </FONT><FONT FACE="Courier" SIZE=5>al</FONT><FONT FACE="Times" SIZE=5> (here </FONT><FONT FACE="Courier" SIZE=5>67h</FONT><FONT FACE="Times" SIZE=5>):</P><B><P ALIGN="JUSTIFY"></P></B></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;al, 67h&#9;; al =&#9;&#9;0011 0111</P><P ALIGN="JUSTIFY">&#9;&#9;xor&#9;al, 08h&#9;; xor it with&#9;<U>0100 0011</P></U><P ALIGN="JUSTIFY">&#9;&#9;&#9;&#9;&#9;; al is 34h&#9;&#9;0111 0100</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">A common use of </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5> is to clear a register, i.e. set all bits to </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>, for example, we can clear register </FONT><FONT FACE="Courier" SIZE=5>cx</FONT><FONT FACE="Times" SIZE=5> as follows</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;xor&#9;cx, cx&#9;</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">This is because when the identical operands are </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5>ed, each bit cancels itself, producing </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>:</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;0 xor 0 produces 0 </P><P ALIGN="JUSTIFY">&#9;1 xor 1 produces 0</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Thus </FONT><FONT FACE="Courier" SIZE=5>abcdefgh</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>abcdefgh</FONT><FONT FACE="Times" SIZE=5> produces </FONT><FONT FACE="Courier" SIZE=5>00000000</FONT><FONT FACE="Times" SIZE=5> where </FONT><FONT FACE="Courier" SIZE=5>abcdefgh</FONT><FONT FACE="Times" SIZE=5> represents some bit pattern. The more obvious way of clearing a register is to use a</FONT><FONT FACE="Courier" SIZE=5> mov </FONT><FONT FACE="Times" SIZE=5>instruction as in:</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;mov&#9;cx, 0&#9;&#9;</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">but this is slower to execute and occupies more memory than the </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5> instruction. This is because bit manipulation instructions, such as </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5>, can be implemented very efficiently in hardware. The </FONT><FONT FACE="Courier" SIZE=5>sub</FONT><FONT FACE="Times" SIZE=5> instruction may also be used to clear a register:</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;sub&#9;cx, cx&#9;</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">It is also smaller and faster than the </FONT><FONT FACE="Courier" SIZE=5>mov</FONT><FONT FACE="Times" SIZE=5> version, but not as fast as the </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5> version. My own preference is to use the clearer version, i.e. the </FONT><FONT FACE="Courier" SIZE=5>mov</FONT><FONT FACE="Times" SIZE=5> instruction. However, in practice, assembly language programs are used where efficiency is important and so clearing a register with </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5> is often used.</P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">4.1.4 The </FONT><FONT FACE="Courier" SIZE=5>not</FONT><FONT FACE="Times" SIZE=5> instruction</P></B><P ALIGN="JUSTIFY">The </FONT><FONT FACE="Courier" SIZE=5>not</FONT><FONT FACE="Times" SIZE=5> operation <B>complements</B> or <B>inverts</B> a bit, i.e.</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;not 1 returns 0</P><P ALIGN="JUSTIFY">&#9;not 0 returns 1</P></FONT><B><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P></B><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">The </FONT><B><FONT FACE="Courier" SIZE=5>not</B></FONT><FONT FACE="Times" SIZE=5> instruction inverts <B>all</B> of the bits of its operand.</P><B><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Example 4.8</B>: Complementing the </FONT><FONT FACE="Courier" SIZE=5>al</FONT><FONT FACE="Times" SIZE=5> register:</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;&#9;mov&#9;al, 33h&#9;&#9;; al = &#9;&#9;00110011</P><P ALIGN="JUSTIFY">&#9;&#9;not&#9;al&#9;&#9;&#9;; al =&#9;&#9;11001100</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">Table 1 summarises the results of the logical operations. Such a table is called a <B>truth table</B>.</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY"><IMG SRC="Image31.gif" WIDTH=300 HEIGHT=195></P><B><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Table 4.1: </B>Truth table for logical operators</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P><B><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">Efficiency</P></B><P ALIGN="JUSTIFY">As noted earlier, the </FONT><FONT FACE="Courier" SIZE=5>xor</FONT><FONT FACE="Times" SIZE=5> instruction is often used to clear an operand because of its efficiency. For similar reasons of efficiency, the </FONT><FONT FACE="Courier" SIZE=5>or/and</FONT><FONT FACE="Times" SIZE=5> instructions may be used to compare an operand to </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5>.</P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">Example 4.9: </B>Comparing an operand to </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> using logical instructions:</P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Courier"><P ALIGN="JUSTIFY">&#9;&#9;or&#9;cx, cx&#9;&#9;; compares cx with 0</P><P ALIGN="JUSTIFY">&#9;&#9;je&#9;label</P><P ALIGN="JUSTIFY">&#9;&#9;and&#9;ax, ax&#9;&#9;; compares ax with 0</P><P ALIGN="JUSTIFY">&#9;&#9;jg&#9;label2</P></FONT><FONT FACE="Times" SIZE=5><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">Doing </FONT><FONT FACE="Courier" SIZE=5>or/and</FONT><FONT FACE="Times" SIZE=5> operations on identical operands, does not change the destination operand (</FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>or</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5> returns </FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5>; </FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>and</FONT><FONT FACE="Times" SIZE=5> </FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5> returns </FONT><FONT FACE="Courier" SIZE=5>x</FONT><FONT FACE="Times" SIZE=5> ), but they do set flags in the status register. The </FONT><FONT FACE="Courier" SIZE=5>or/and</FONT><FONT FACE="Times" SIZE=5> instructions above have the same effect as the </FONT><FONT FACE="Courier" SIZE=5>cmp</FONT><FONT FACE="Times" SIZE=5> instructions used in Example 4.10, but they are faster and smaller instructions (each occupies </FONT><FONT FACE="Courier" SIZE=5>2</FONT><FONT FACE="Times" SIZE=5> bytes) than the </FONT><FONT FACE="Courier" SIZE=5>cmp</FONT><FONT FACE="Times" SIZE=5> instruction ( which occupies </FONT><FONT FACE="Courier" SIZE=5>3</FONT><FONT FACE="Times" SIZE=5> bytes).</P><P ALIGN="JUSTIFY"></P><P ALIGN="JUSTIFY">&nbsp;</P><P ALIGN="JUSTIFY">&nbsp;</P><B><P ALIGN="JUSTIFY">Shifting and Rotating Bits </P></B><P ALIGN="JUSTIFY">We sometimes wish to change the positions of all the bits in a byte, word or long word. The 8086 provides a complete set of instructions for shifting and rotating bits. Bits can be moved right (towards the </FONT><FONT FACE="Courier" SIZE=5>0</FONT><FONT FACE="Times" SIZE=5> bit) or left towards the most significant bit. Values shifted off the end of an operand are lost (one may go into the <B>carry flag</B>). </P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">Shift</B> instructions move bits a specified number of places to the right or left. </P><P ALIGN="JUSTIFY"></P><B><P ALIGN="JUSTIFY">Rotate</B> instructions move bits a specified number of places to the right or left. For each bit rotated, the last bit in the direction of the rotate is moved into the first bit position at the other end of the operand. </P><P ALIGN="JUSTIFY"></P></FONT><FONT FACE="Times" SIZE=6><P>&nbsp;</P></FONT></BODY></HTML>